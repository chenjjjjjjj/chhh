# 结构性设计模式

主要是将类和对象组装成更大的来使用。

![image-20250313143333156](%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F.assets/image-20250313143333156.png)

## 适配器模式 Adapter

将一个类的**接口转换**成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

主要由三个角色组成：

| 角色         | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| **目标接口** | 客户端期望调用的接口（例如 `USB-C` 接口）                    |
| **被适配者** | 需要被适配的现有接口（例如 `MicroUSB` 接口）                 |
| **适配器**   | 包装被适配者，将其转换成目标接口（例如 `MicroUSB转USB-C` 转换头） |

~~~java
// 目标接口：USB-C
interface USBC {
    void connectUSBC();
}

// 被适配者：MicroUSB
class MicroUSB {
    void connectMicroUSB() {
        System.out.println("MicroUSB已连接");
    }
}

// 适配器：将MicroUSB转换为USBC接口
class MicroUSBAdapter implements USBC {
    private MicroUSB microUSB;

    public MicroUSBAdapter(MicroUSB microUSB) {
        this.microUSB = microUSB;
    }

    @Override
    public void connectUSBC() {
        microUSB.connectMicroUSB();  // 调用被适配者的方法
    }
}

// 客户端调用
public class Client {
    public static void main(String[] args) {
        MicroUSB oldParser = new MicroUSB();
        USBC adapter = new MicroUSBAdapter(oldParser);
        // 注意：这里是直接输出了，但是很有可能这里是一个方法，这个方法的入参
		// 只能是USBC接口类，我们使用适配器，也可以让MicroUSB进入
        System.out.println(USBC.parseToJSON());  // 输出JSON数据
    }
}
~~~

## 桥接模式bridge

将类的抽象部分和实现部分分离开来，使它们可以独立地变化 (继承树拆分)

**两个树**

示例：将图形和渲染方式分离，通过组合关系动态绑定，我们在客户端进行任意组合的方式，实现图形和渲染的分离。

抽象层

~~~java
// 图形抽象类（抽象层）
abstract class Shape {
    protected Renderer renderer;  // 组合渲染引擎
    
    public Shape(Renderer renderer) {
        this.renderer = renderer;
    }
    
    public abstract void draw();
}

// 具体图形实现
class Circle extends Shape {
    public Circle(Renderer renderer) {
        super(renderer);
    }

    @Override
    public void draw() {
        renderer.renderShape("圆形");
    }
}

class Rectangle extends Shape {
    public Rectangle(Renderer renderer) {
        super(renderer);
    }

    @Override
    public void draw() {
        renderer.renderShape("矩形");
    }
}
~~~

实现层

~~~java
// 渲染引擎接口（实现层）
interface Renderer {
    void renderShape(String shapeType);
}

// 具体渲染实现
class VectorRenderer implements Renderer {
    @Override
    public void renderShape(String shapeType) {
        System.out.println("绘制矢量" + shapeType);
    }
}

class BitmapRenderer implements Renderer {
    @Override
    public void renderShape(String shapeType) {
        System.out.println("绘制位图" + shapeType);
    }
}
~~~

客户端维护

~~~java
public class Client {
    public static void main(String[] args) {
        // 动态组合图形和渲染方式
        Renderer vector = new VectorRenderer();
        Renderer bitmap = new BitmapRenderer();

        Shape circle = new Circle(vector);    // 矢量圆形
        circle.draw();  // 输出: 绘制矢量圆形

        Shape rect = new Rectangle(bitmap);   // 位图矩形
        rect.draw();    // 输出: 绘制位图矩形
    }
}
~~~



## 组合模式Composite

树形结构处理的设计模式，允许将对象组合成树形结构来表示“部分-整体”的层次关系

底层的叶子节点是部分，上面的节点是根据叶子节点进行组合起来的组合节点是整体

叶子节点：表示没有子节点的节点

## 装饰模式Decorator

动态的给一个对象添加一些额外的职责

举个例子来说，就是我们给咖啡加糖，但是不改变咖啡本身，而是增加咖啡甜味儿功能；这样做的好处是，避免了继承的臃肿，通过组合实现功能的叠加

解释：

1. 抽象构件(Cmponent)：定义对象的基础接口。例如coffee接口

2. 具体构件ConcreteComponent，实现基础功能的具体对象。比如说simpleCoffee类，提供基础咖啡的实现

3. Decorator装饰器，继承抽象构件并持有其引用，用于包装具体构件。例如：CoffeeDecorator抽象类，包含coffee对象。

4. 具体装饰器(ConcreteDecorator)，添加具体的附加功能。

   例如：MilkDecorator和SugarDecorator类，分别添加牛奶和糖的功能。



![装饰器模式_Java技术栈](%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F.assets/f9b39d598c79750d779a391e1915a081.png)

~~~java
// 咖啡接口
public interface Coffee {
    double getCost();
    String getDescription();
}

// 基础咖啡实现
class Espresso implements Coffee {
    @Override
    public double getCost() { return 1.99; }

    @Override
    public String getDescription() { return "浓缩咖啡"; }
}


// 装饰器抽象类
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;// 持有产品接口，这里持有接口拓展性更强。

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }

    public double getCost() {
        return decoratedCoffee.getCost();
    }

    public String getDescription() {
        return decoratedCoffee.getDescription();
    }
}


// 牛奶装饰器
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public double getCost() {
        // 具体构件的价格 + 我们牛奶的价格
        return super.getCost() + 0.5; // 增加牛奶价格
    }

    @Override
    public String getDescription() {
        return super.getDescription() + " + 牛奶";
    }
}

// 糖装饰器（类似实现）
class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public double getCost() { return super.getCost() + 0.2; }

    @Override
    public String getDescription() { return super.getDescription() + " + 糖"; }
}


public class Main {
    public static void main(String[] args) {
        // 1. 基础咖啡
        Coffee coffee = new SimpleCoffee();
        System.out.println("基础咖啡: " + coffee.description() + ", 价格: " + coffee.cost());

        // 2. 加牛奶的咖啡
        Coffee milkCoffee = new MilkDecorator(new SimpleCoffee());
        System.out.println("加牛奶咖啡: " + milkCoffee.description() + ", 价格: " + milkCoffee.cost());

        // 3. 加牛奶和糖的咖啡（装饰器嵌套）
        Coffee milkAndSugarCoffee = new SugarDecorator(new MilkDecorator(new SimpleCoffee()));
        System.out.println("加牛奶和糖: " + milkAndSugarCoffee.description() + ", 价格: " + milkAndSugarCoffee.cost());

        // 4. 任意组合：先加糖，再加牛奶
        Coffee sugarAndMilkCoffee = new MilkDecorator(new SugarDecorator(new SimpleCoffee()));
        System.out.println("先糖后牛奶: " + sugarAndMilkCoffee.description() + ", 价格: " + sugarAndMilkCoffee.cost());
    }
}


~~~



## 外观模式Facade

目的：通过提供统一的简化接口，隐藏子系统的复杂性，从而降低客户端与子系统的耦合度

外观角色，提供统一的高层接口，协调子系统完成复杂逻辑

子系统，实现具体功能的模块

~~~java
// 灯光子系统
class LightSystem {
    public void dimLights() { System.out.println("灯光调暗至50%"); }
}

// 空调子系统
class AirConditioner {
    public void setTemperature(int temp) { System.out.println("空调温度设置为" + temp + "℃"); }
}

// 音响子系统
class SoundSystem {
    public void playMovieAudio() { System.out.println("音响切换至影院模式"); }
}

class HomeTheaterFacade {
    private LightSystem lights;
    private AirConditioner ac;
    private SoundSystem sound;

    public HomeTheaterFacade() {
        this.lights = new LightSystem();
        this.ac = new AirConditioner();
        this.sound = new SoundSystem();
    }

    // 统一入口：一键启动观影模式
    public void startMovieMode() {
        lights.dimLights();
        ac.setTemperature(22);
        sound.playMovieAudio();
        System.out.println(">>> 观影模式已就绪 <<<");
    }
}

public class Client {
    public static void main(String[] args) {
        HomeTheaterFacade facade = new HomeTheaterFacade();
        facade.startMovieMode();
    }
}
~~~



## 享元模式Flyweight

核心目标是通过共享技术减少大量相似对象的内存占用，将对象的属性分为内部状态(可共享)和外部状态(不可共享)，通过复用相同的内部状态来优化资源消耗。

![image-20250314135134460](结构性模式.assets/image-20250314135134460.png)****

## 代理模式Proxy

通过代理对象间接访问目标对象，从而在访问钱后添加额外控制逻辑，他的本质是拦截。

核心价值：

1. 控制访问，限制和增强对真实对象的操作，比如全校校验
2. 功能解耦，对于非核心逻辑从真实对象中抽离
3. 延迟加载，只有在需要时才初始化高开销对象，我们通过在代理对象中进行校验，检查是否需要真实对象的创建。

![image-20250314141025190](结构性模式.assets/image-20250314141025190.png)



这几种结构性模式，分别适用什么场景呢？

适配器模式

个人理解，只要记住他是进行接口转换的，比如说我们想要适用一个类，但是我们的方法不支持这个类，我们可以通过适配器来进行转换，就可以使用这个类了，这是他的思想，关于他的适用场景基本上还是围绕着这个核心思想来做的。

桥接模式 理解不透彻

他的核心思想是把属性和行为操作分开，左边是属性，右边是行为操作。

组合模式

1. 想表示对象的部分-整体层次结构
2. 希望用户忽略组合对象与单个对象的不同，用户统一组合结构中的所有对象

装饰器模式 理解不透彻

1. 在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责
2. 处理那些可以撤销的职责

外观模式

主要目的还是为了通过提供统一的简化接口，隐藏子系统的复杂性，从而降低客户端与子系统的耦合度

享元模式

共享的理念









